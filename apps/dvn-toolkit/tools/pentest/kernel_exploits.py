#!/usr/bin/env python3
"""
Kernel Exploit Suggester
Suggests potential kernel exploits based on kernel version
For authorized security testing only
"""

import os
import sys
import subprocess
import re
import argparse
from typing import List, Dict, Tuple

# Colors
class C:
    R = '\033[91m'
    Y = '\033[93m'
    G = '\033[92m'
    B = '\033[94m'
    M = '\033[95m'
    C = '\033[96m'
    E = '\033[0m'

def banner():
    print(f"""{C.R}
    __ __                     __   ______           __      _ __
   / //_/__  _________  ___  / /  / ____/  ______  / /___  (_) /_
  / ,< / _ \/ ___/ __ \/ _ \/ /  / __/ | |/_/ __ \/ / __ \/ / __/
 / /| /  __/ /  / / / /  __/ /  / /____>  </ /_/ / / /_/ / / /_
/_/ |_\___/_/  /_/ /_/\___/_/  /_____/_/|_/ .___/_/\____/_/\__/
                                         /_/
{C.E}{C.Y}Linux Kernel Exploit Suggester{C.E}
""")

# Kernel exploits database
# Format: (min_version, max_version, cve, name, description, exploit_db, github)
KERNEL_EXPLOITS = [
    # Dirty COW (2007-2016)
    ((2, 6, 22), (4, 8, 3), 'CVE-2016-5195', 'Dirty COW',
     'Race condition in mm/gup.c allows local privilege escalation',
     'https://www.exploit-db.com/exploits/40839',
     'https://github.com/dirtycow/dirtycow.github.io'),

    # Dirty Pipe (2022)
    ((5, 8, 0), (5, 16, 11), 'CVE-2022-0847', 'Dirty Pipe',
     'Pipe buffer flag issue allows overwriting arbitrary files',
     'https://www.exploit-db.com/exploits/50808',
     'https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits'),

    # PwnKit (2022)
    ((2, 6, 0), (5, 17, 0), 'CVE-2021-4034', 'PwnKit (pkexec)',
     'Memory corruption in polkit pkexec',
     'https://www.exploit-db.com/exploits/50689',
     'https://github.com/berdav/CVE-2021-4034'),

    # Overlayfs
    ((3, 18, 0), (4, 3, 3), 'CVE-2015-8660', 'Overlayfs',
     'Overlayfs privilege escalation',
     'https://www.exploit-db.com/exploits/39230',
     'https://github.com/rebel028/overlayfs'),

    # Netfilter
    ((5, 4, 0), (5, 6, 10), 'CVE-2022-25636', 'Netfilter',
     'Heap out-of-bounds write in nf_dup_netdev.c',
     'https://www.exploit-db.com/exploits/50826',
     'https://github.com/Bonfee/CVE-2022-25636'),

    # RDS
    ((2, 6, 30), (2, 6, 36), 'CVE-2010-3904', 'RDS',
     'Reliable Datagram Sockets privilege escalation',
     'https://www.exploit-db.com/exploits/15285',
     None),

    # Full Nelson
    ((2, 6, 31), (2, 6, 36), 'CVE-2010-4258', 'Full Nelson',
     'Econet + RDS privilege escalation',
     'https://www.exploit-db.com/exploits/15704',
     None),

    # Half Nelson
    ((2, 6, 0), (2, 6, 36), 'CVE-2010-3848', 'Half Nelson',
     'Econet privilege escalation',
     'https://www.exploit-db.com/exploits/17787',
     None),

    # PTRACE_TRACEME
    ((4, 10, 0), (5, 1, 17), 'CVE-2019-13272', 'PTRACE_TRACEME',
     'ptrace privilege escalation',
     'https://www.exploit-db.com/exploits/47163',
     'https://github.com/bcoles/kernel-exploits/tree/master/CVE-2019-13272'),

    # eBPF
    ((4, 4, 0), (4, 14, 8), 'CVE-2017-16995', 'eBPF_verifier',
     'eBPF verifier arbitrary read/write',
     'https://www.exploit-db.com/exploits/45010',
     'https://github.com/brl/grlern/tree/master/CVE-2017-16995'),

    # AF_PACKET
    ((4, 4, 0), (4, 13, 0), 'CVE-2017-7308', 'AF_PACKET',
     'AF_PACKET race condition',
     'https://www.exploit-db.com/exploits/44654',
     None),

    # ip6_append_data
    ((2, 6, 0), (4, 11, 0), 'CVE-2017-1000112', 'ip6_append_data',
     'UDP fragmentation offload memory corruption',
     'https://www.exploit-db.com/exploits/43418',
     None),

    # KASLR Bypass
    ((4, 8, 0), (4, 19, 0), 'CVE-2018-18955', 'KASLR Bypass',
     'map_write user namespace bypass',
     None,
     'https://github.com/bcoles/kernel-exploits/tree/master/CVE-2018-18955'),

    # Netfilter nft_expr_lookup
    ((5, 8, 0), (5, 19, 0), 'CVE-2023-0179', 'Netfilter nft',
     'Integer overflow in nft_expr_lookup',
     None,
     'https://github.com/TurtleARM/CVE-2023-0179-PoC'),

    # io_uring
    ((5, 1, 0), (5, 18, 14), 'CVE-2022-29582', 'io_uring',
     'io_uring use-after-free',
     None,
     'https://github.com/Ruia-ruia/CVE-2022-29582-Exploit'),

    # pipe
    ((2, 6, 11), (4, 9, 0), 'CVE-2017-6074', 'DCCP Double Free',
     'DCCP double-free vulnerability',
     'https://www.exploit-db.com/exploits/41458',
     None),

    # n_tty
    ((2, 6, 31), (3, 14, 0), 'CVE-2014-0196', 'rawmodePTY',
     'n_tty race condition',
     'https://www.exploit-db.com/exploits/33516',
     None),

    # perf_swevent
    ((2, 6, 32), (3, 8, 9), 'CVE-2013-2094', 'perf_swevent',
     'perf_event overflow',
     'https://www.exploit-db.com/exploits/25444',
     None),

    # msr
    ((2, 6, 18), (3, 7, 10), 'CVE-2013-0268', 'msr',
     '/dev/msr arbitrary write',
     'https://www.exploit-db.com/exploits/27297',
     None),

    # sock_sendpage
    ((2, 4, 0), (2, 6, 30), 'CVE-2009-2692', 'sock_sendpage',
     'null pointer dereference',
     'https://www.exploit-db.com/exploits/9641',
     None),

    # Sudo Baron Samedit
    ((0, 0, 0), (99, 0, 0), 'CVE-2021-3156', 'Baron Samedit (Sudo)',
     'Sudo heap-based buffer overflow (sudo 1.8.2-1.8.31p2, 1.9.0-1.9.5p1)',
     'https://www.exploit-db.com/exploits/49521',
     'https://github.com/blasty/CVE-2021-3156'),
]

def parse_version(version_str: str) -> Tuple[int, int, int]:
    """Parse kernel version string"""
    match = re.match(r'(\d+)\.(\d+)(?:\.(\d+))?', version_str)
    if match:
        major = int(match.group(1))
        minor = int(match.group(2))
        patch = int(match.group(3)) if match.group(3) else 0
        return (major, minor, patch)
    return (0, 0, 0)

def version_in_range(version: Tuple, min_ver: Tuple, max_ver: Tuple) -> bool:
    """Check if version is in range"""
    return min_ver <= version <= max_ver

def get_kernel_version() -> str:
    """Get current kernel version"""
    try:
        result = subprocess.run(['uname', '-r'], capture_output=True, text=True)
        return result.stdout.strip()
    except:
        return ""

def get_system_info() -> Dict:
    """Get system information"""
    info = {}

    info['kernel'] = get_kernel_version()

    try:
        with open('/etc/os-release', 'r') as f:
            for line in f:
                if '=' in line:
                    key, val = line.strip().split('=', 1)
                    info[key.lower()] = val.strip('"')
    except:
        pass

    # Check sudo version
    try:
        result = subprocess.run(['sudo', '-V'], capture_output=True, text=True)
        match = re.search(r'Sudo version (\d+\.\d+(?:\.\d+)?)', result.stdout)
        if match:
            info['sudo_version'] = match.group(1)
    except:
        pass

    # Check gcc version
    try:
        result = subprocess.run(['gcc', '--version'], capture_output=True, text=True)
        match = re.search(r'gcc.*?(\d+\.\d+\.\d+)', result.stdout)
        if match:
            info['gcc_version'] = match.group(1)
    except:
        pass

    return info

def find_exploits(kernel_version: str) -> List[Dict]:
    """Find applicable exploits for kernel version"""
    version = parse_version(kernel_version)
    applicable = []

    for exploit in KERNEL_EXPLOITS:
        min_ver, max_ver, cve, name, desc, exploit_db, github = exploit

        if version_in_range(version, min_ver, max_ver):
            applicable.append({
                'cve': cve,
                'name': name,
                'description': desc,
                'exploit_db': exploit_db,
                'github': github,
                'min_version': '.'.join(map(str, min_ver)),
                'max_version': '.'.join(map(str, max_ver)),
            })

    return applicable

def check_exploit_requirements(exploit: Dict) -> List[str]:
    """Check if exploit requirements are met"""
    requirements = []

    # Check if GCC is available for compilation
    try:
        subprocess.run(['gcc', '--version'], capture_output=True, check=True)
    except:
        requirements.append("GCC not available - may need for compilation")

    # Check if /tmp is noexec
    try:
        result = subprocess.run(['mount'], capture_output=True, text=True)
        if 'noexec' in result.stdout and '/tmp' in result.stdout:
            requirements.append("/tmp has noexec - find alternative location")
    except:
        pass

    return requirements

def main():
    parser = argparse.ArgumentParser(description='Kernel Exploit Suggester')
    parser.add_argument('-k', '--kernel', help='Specify kernel version')
    parser.add_argument('-a', '--all', action='store_true', help='Show all exploits')
    parser.add_argument('-c', '--cve', help='Search by CVE')
    parser.add_argument('--json', action='store_true', help='Output JSON')
    args = parser.parse_args()

    banner()

    # Get system info
    sys_info = get_system_info()
    kernel_version = args.kernel or sys_info.get('kernel', '')

    if not kernel_version:
        print(f"{C.R}[ERROR]{C.E} Could not determine kernel version")
        sys.exit(1)

    print(f"{C.B}[System Information]{C.E}")
    print(f"  Kernel: {kernel_version}")
    print(f"  OS: {sys_info.get('pretty_name', 'Unknown')}")
    if sys_info.get('sudo_version'):
        print(f"  Sudo: {sys_info['sudo_version']}")
    if sys_info.get('gcc_version'):
        print(f"  GCC: {sys_info['gcc_version']}")
    print()

    # Find exploits
    if args.all:
        exploits = [
            {
                'cve': e[2], 'name': e[3], 'description': e[4],
                'exploit_db': e[5], 'github': e[6],
                'min_version': '.'.join(map(str, e[0])),
                'max_version': '.'.join(map(str, e[1])),
            }
            for e in KERNEL_EXPLOITS
        ]
    elif args.cve:
        exploits = [
            {
                'cve': e[2], 'name': e[3], 'description': e[4],
                'exploit_db': e[5], 'github': e[6],
                'min_version': '.'.join(map(str, e[0])),
                'max_version': '.'.join(map(str, e[1])),
            }
            for e in KERNEL_EXPLOITS if args.cve.upper() in e[2]
        ]
    else:
        exploits = find_exploits(kernel_version)

    if args.json:
        import json
        print(json.dumps(exploits, indent=2))
        return

    print(f"{C.B}[Potential Exploits]{C.E}")

    if not exploits:
        print(f"  {C.G}No known exploits found for this kernel version{C.E}")
        print(f"  {C.Y}Note: This doesn't mean the system is secure!{C.E}")
    else:
        print(f"  Found {C.R}{len(exploits)}{C.E} potential exploit(s)\n")

        for i, exp in enumerate(exploits, 1):
            print(f"  {C.R}[{i}] {exp['name']}{C.E}")
            print(f"      CVE: {C.Y}{exp['cve']}{C.E}")
            print(f"      Versions: {exp['min_version']} - {exp['max_version']}")
            print(f"      {exp['description']}")

            if exp.get('exploit_db'):
                print(f"      {C.C}Exploit-DB:{C.E} {exp['exploit_db']}")
            if exp.get('github'):
                print(f"      {C.C}GitHub:{C.E} {exp['github']}")

            # Check requirements
            reqs = check_exploit_requirements(exp)
            if reqs:
                print(f"      {C.Y}Requirements:{C.E}")
                for req in reqs:
                    print(f"        - {req}")

            print()

    print(f"{C.Y}[*] Always verify exploits in a safe environment first{C.E}")
    print(f"{C.Y}[*] Check kernel config and security modules (SELinux, AppArmor){C.E}")

if __name__ == '__main__':
    main()
