#!/usr/bin/env python3
"""
Linux Privilege Escalation Checker
Finds common misconfigurations that can lead to privilege escalation
For authorized security testing only
"""

import os
import sys
import subprocess
import stat
import pwd
import grp
from pathlib import Path
from typing import List, Dict, Tuple
import argparse

# Colors
class C:
    R = '\033[91m'  # Red - Critical
    Y = '\033[93m'  # Yellow - Warning
    G = '\033[92m'  # Green - Info
    B = '\033[94m'  # Blue - Header
    M = '\033[95m'  # Magenta
    C = '\033[96m'  # Cyan
    W = '\033[97m'  # White
    E = '\033[0m'   # End

def banner():
    print(f"""{C.R}
    ____       _       ______
   / __ \_____(_)   __/ ____/___  _____
  / /_/ / ___/ / | / / __/ / __ \/ ___/
 / ____/ /  / /| |/ / /___/ /_/ / /__
/_/   /_/  /_/ |___/_____/\____/\___/
{C.E}{C.Y}Linux Privilege Escalation Checker{C.E}
""")

def run_cmd(cmd: str) -> str:
    """Run shell command and return output"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=30)
        return result.stdout.strip()
    except:
        return ""

def get_current_user() -> Dict:
    """Get current user info"""
    uid = os.getuid()
    gid = os.getgid()
    groups = os.getgroups()

    return {
        'uid': uid,
        'gid': gid,
        'user': pwd.getpwuid(uid).pw_name,
        'group': grp.getgrgid(gid).gr_name,
        'groups': [grp.getgrgid(g).gr_name for g in groups],
        'home': os.environ.get('HOME', '/tmp'),
        'shell': os.environ.get('SHELL', '/bin/sh')
    }

def check_sudo_nopasswd() -> List[str]:
    """Check for NOPASSWD sudo entries"""
    findings = []

    # Check sudo -l
    sudo_l = run_cmd("sudo -l 2>/dev/null")
    if sudo_l and "NOPASSWD" in sudo_l:
        findings.append(f"{C.R}[CRITICAL]{C.E} NOPASSWD sudo entries found:")
        for line in sudo_l.split('\n'):
            if "NOPASSWD" in line:
                findings.append(f"  {C.Y}{line.strip()}{C.E}")

    # Check sudoers files
    sudoers_files = ['/etc/sudoers'] + list(Path('/etc/sudoers.d').glob('*')) if Path('/etc/sudoers.d').exists() else ['/etc/sudoers']

    for sf in sudoers_files:
        try:
            with open(sf, 'r') as f:
                for line in f:
                    if 'NOPASSWD' in line and not line.strip().startswith('#'):
                        findings.append(f"  {C.Y}{sf}: {line.strip()}{C.E}")
        except:
            pass

    return findings

def find_suid_sgid() -> List[str]:
    """Find SUID/SGID binaries"""
    findings = []

    # Known exploitable SUID binaries (GTFOBins)
    exploitable = [
        'nmap', 'vim', 'vi', 'nano', 'less', 'more', 'man', 'awk', 'gawk',
        'perl', 'python', 'python2', 'python3', 'ruby', 'lua', 'php',
        'find', 'cp', 'mv', 'dd', 'tar', 'zip', 'gzip', 'bash', 'sh',
        'dash', 'zsh', 'ksh', 'csh', 'env', 'time', 'timeout', 'strace',
        'ltrace', 'gdb', 'node', 'tclsh', 'wish', 'expect', 'ed', 'sed',
        'busybox', 'docker', 'lxc', 'runc', 'systemctl', 'journalctl',
        'apt-get', 'apt', 'yum', 'dnf', 'rpm', 'dpkg', 'pkexec', 'doas',
        'mount', 'umount', 'fusermount', 'ntfs-3g', 'exim', 'screen',
        'tmux', 'ftp', 'sftp', 'scp', 'ssh', 'rsync', 'wget', 'curl',
        'nc', 'netcat', 'ncat', 'socat', 'openssl', 'base64', 'xxd'
    ]

    # Find SUID
    suid_cmd = "find / -perm -4000 -type f 2>/dev/null"
    suid_files = run_cmd(suid_cmd).split('\n')

    # Find SGID
    sgid_cmd = "find / -perm -2000 -type f 2>/dev/null"
    sgid_files = run_cmd(sgid_cmd).split('\n')

    findings.append(f"{C.B}[SUID Binaries]{C.E}")
    for f in suid_files:
        if f:
            name = os.path.basename(f)
            if name in exploitable:
                findings.append(f"  {C.R}[EXPLOIT]{C.E} {f} - Check GTFOBins!")
            else:
                findings.append(f"  {C.Y}{f}{C.E}")

    findings.append(f"\n{C.B}[SGID Binaries]{C.E}")
    for f in sgid_files:
        if f:
            name = os.path.basename(f)
            if name in exploitable:
                findings.append(f"  {C.R}[EXPLOIT]{C.E} {f} - Check GTFOBins!")
            else:
                findings.append(f"  {C.Y}{f}{C.E}")

    return findings

def find_capabilities() -> List[str]:
    """Find files with capabilities"""
    findings = []

    # Dangerous capabilities
    dangerous_caps = [
        'cap_setuid', 'cap_setgid', 'cap_dac_override', 'cap_dac_read_search',
        'cap_sys_admin', 'cap_sys_ptrace', 'cap_chown', 'cap_fowner',
        'cap_net_raw', 'cap_net_admin', 'cap_sys_module'
    ]

    cap_output = run_cmd("getcap -r / 2>/dev/null")

    if cap_output:
        findings.append(f"{C.B}[Files with Capabilities]{C.E}")
        for line in cap_output.split('\n'):
            if line:
                is_dangerous = any(cap in line.lower() for cap in dangerous_caps)
                if is_dangerous:
                    findings.append(f"  {C.R}[DANGEROUS]{C.E} {line}")
                else:
                    findings.append(f"  {C.Y}{line}{C.E}")

    return findings

def check_writable_paths() -> List[str]:
    """Check for writable paths in PATH and important directories"""
    findings = []

    # Check PATH directories
    path_dirs = os.environ.get('PATH', '').split(':')
    findings.append(f"{C.B}[Writable PATH Directories]{C.E}")

    for d in path_dirs:
        if d and os.path.exists(d):
            if os.access(d, os.W_OK):
                findings.append(f"  {C.R}[WRITABLE]{C.E} {d}")

    # Check important directories
    important_dirs = [
        '/etc', '/etc/cron.d', '/etc/cron.daily', '/etc/cron.hourly',
        '/etc/cron.weekly', '/etc/cron.monthly', '/etc/init.d',
        '/etc/systemd/system', '/usr/lib/systemd/system',
        '/var/spool/cron', '/var/spool/cron/crontabs'
    ]

    findings.append(f"\n{C.B}[Writable System Directories]{C.E}")
    for d in important_dirs:
        if os.path.exists(d) and os.access(d, os.W_OK):
            findings.append(f"  {C.R}[WRITABLE]{C.E} {d}")

    return findings

def check_writable_files() -> List[str]:
    """Check for writable sensitive files"""
    findings = []

    sensitive_files = [
        '/etc/passwd', '/etc/shadow', '/etc/sudoers', '/etc/hosts',
        '/etc/crontab', '/etc/ssh/sshd_config', '/etc/ld.so.conf',
        '/etc/ld.so.conf.d/', '/etc/profile', '/etc/bashrc',
        '/etc/environment', '/root/.bashrc', '/root/.profile'
    ]

    findings.append(f"{C.B}[Writable Sensitive Files]{C.E}")
    for f in sensitive_files:
        if os.path.exists(f) and os.access(f, os.W_OK):
            findings.append(f"  {C.R}[CRITICAL]{C.E} {f} is writable!")

    return findings

def check_cron_jobs() -> List[str]:
    """Analyze cron jobs for vulnerabilities"""
    findings = []
    findings.append(f"{C.B}[Cron Jobs Analysis]{C.E}")

    # System crontab
    crontab = run_cmd("cat /etc/crontab 2>/dev/null")
    if crontab:
        findings.append(f"\n  {C.C}/etc/crontab:{C.E}")
        for line in crontab.split('\n'):
            if line and not line.startswith('#'):
                findings.append(f"    {line}")

    # Cron directories
    cron_dirs = ['/etc/cron.d', '/etc/cron.daily', '/etc/cron.hourly',
                 '/etc/cron.weekly', '/etc/cron.monthly']

    for d in cron_dirs:
        if os.path.exists(d):
            files = os.listdir(d)
            if files:
                findings.append(f"\n  {C.C}{d}:{C.E}")
                for f in files:
                    fp = os.path.join(d, f)
                    if os.access(fp, os.W_OK):
                        findings.append(f"    {C.R}[WRITABLE]{C.E} {f}")
                    else:
                        findings.append(f"    {f}")

    # User crontabs
    user_cron = run_cmd("crontab -l 2>/dev/null")
    if user_cron:
        findings.append(f"\n  {C.C}Current user crontab:{C.E}")
        for line in user_cron.split('\n'):
            findings.append(f"    {line}")

    return findings

def check_ssh_keys() -> List[str]:
    """Find SSH keys and configs"""
    findings = []
    findings.append(f"{C.B}[SSH Keys & Configs]{C.E}")

    # Common SSH key locations
    ssh_locations = [
        os.path.expanduser('~/.ssh'),
        '/root/.ssh',
        '/etc/ssh'
    ]

    for loc in ssh_locations:
        if os.path.exists(loc):
            findings.append(f"\n  {C.C}{loc}:{C.E}")
            try:
                for f in os.listdir(loc):
                    fp = os.path.join(loc, f)
                    if os.path.isfile(fp):
                        readable = os.access(fp, os.R_OK)
                        if 'id_' in f or 'key' in f.lower():
                            if readable:
                                findings.append(f"    {C.R}[KEY]{C.E} {f} - READABLE!")
                            else:
                                findings.append(f"    {C.Y}[KEY]{C.E} {f}")
                        elif f == 'authorized_keys':
                            if os.access(fp, os.W_OK):
                                findings.append(f"    {C.R}[WRITABLE]{C.E} {f}")
                            else:
                                findings.append(f"    {f}")
                        else:
                            findings.append(f"    {f}")
            except PermissionError:
                findings.append(f"    {C.Y}Permission denied{C.E}")

    return findings

def check_interesting_files() -> List[str]:
    """Find interesting files (passwords, configs, backups)"""
    findings = []
    findings.append(f"{C.B}[Interesting Files]{C.E}")

    # Search patterns
    patterns = [
        ('Password files', 'find /home /root /tmp /var /opt -name "*.txt" -o -name "*pass*" -o -name "*pwd*" 2>/dev/null | head -20'),
        ('Config files', 'find /home /root /var /opt -name "*.conf" -o -name "*.cfg" -o -name "*.ini" 2>/dev/null | head -20'),
        ('Backup files', 'find / -name "*.bak" -o -name "*.backup" -o -name "*.old" -o -name "*~" 2>/dev/null | head -20'),
        ('History files', 'find /home /root -name ".*history" -o -name ".*_history" 2>/dev/null'),
        ('Database files', 'find / -name "*.db" -o -name "*.sqlite" -o -name "*.sql" 2>/dev/null | head -20'),
    ]

    for name, cmd in patterns:
        output = run_cmd(cmd)
        if output:
            findings.append(f"\n  {C.C}{name}:{C.E}")
            for line in output.split('\n')[:10]:
                if line and os.access(line, os.R_OK):
                    findings.append(f"    {C.G}[READABLE]{C.E} {line}")
                elif line:
                    findings.append(f"    {line}")

    return findings

def check_docker_lxc() -> List[str]:
    """Check for Docker/LXC privilege escalation"""
    findings = []

    # Check if user is in docker group
    groups = run_cmd("groups")
    if 'docker' in groups:
        findings.append(f"{C.R}[CRITICAL]{C.E} User is in docker group - can escalate to root!")
        findings.append(f"  {C.Y}Run: docker run -v /:/mnt --rm -it alpine chroot /mnt sh{C.E}")

    if 'lxd' in groups or 'lxc' in groups:
        findings.append(f"{C.R}[CRITICAL]{C.E} User is in lxd/lxc group - can escalate to root!")

    # Check for docker socket
    if os.path.exists('/var/run/docker.sock'):
        if os.access('/var/run/docker.sock', os.W_OK):
            findings.append(f"{C.R}[CRITICAL]{C.E} Docker socket is writable!")

    return findings

def check_kernel() -> List[str]:
    """Check kernel version for known vulnerabilities"""
    findings = []

    kernel = run_cmd("uname -r")
    findings.append(f"{C.B}[Kernel Info]{C.E}")
    findings.append(f"  Version: {kernel}")

    # Known vulnerable kernels (partial list)
    vuln_kernels = {
        '2.6': ['CVE-2009-2692 (sock_sendpage)', 'CVE-2010-3904 (RDS)'],
        '3.': ['CVE-2016-5195 (Dirty COW)', 'CVE-2014-0196 (rawmodePTY)'],
        '4.4': ['CVE-2017-16995 (eBPF)', 'CVE-2017-1000112'],
        '4.15': ['CVE-2019-13272 (PTRACE_TRACEME)'],
        '5.8': ['CVE-2022-0847 (Dirty Pipe)'],
    }

    findings.append(f"\n  {C.C}Potential vulnerabilities:{C.E}")
    for ver, cves in vuln_kernels.items():
        if kernel.startswith(ver):
            for cve in cves:
                findings.append(f"    {C.R}[CHECK]{C.E} {cve}")

    return findings

def main():
    parser = argparse.ArgumentParser(description='Linux Privilege Escalation Checker')
    parser.add_argument('-a', '--all', action='store_true', help='Run all checks')
    parser.add_argument('-s', '--suid', action='store_true', help='Find SUID/SGID binaries')
    parser.add_argument('-c', '--caps', action='store_true', help='Find capabilities')
    parser.add_argument('-w', '--writable', action='store_true', help='Find writable paths/files')
    parser.add_argument('-k', '--cron', action='store_true', help='Check cron jobs')
    parser.add_argument('-S', '--ssh', action='store_true', help='Find SSH keys')
    parser.add_argument('-f', '--files', action='store_true', help='Find interesting files')
    parser.add_argument('-d', '--docker', action='store_true', help='Check Docker/LXC')
    parser.add_argument('-K', '--kernel', action='store_true', help='Check kernel vulns')
    parser.add_argument('--sudo', action='store_true', help='Check sudo config')
    args = parser.parse_args()

    banner()

    # User info
    user = get_current_user()
    print(f"{C.B}[Current User]{C.E}")
    print(f"  User: {user['user']} (uid={user['uid']})")
    print(f"  Group: {user['group']} (gid={user['gid']})")
    print(f"  Groups: {', '.join(user['groups'])}")
    print(f"  Home: {user['home']}")
    print(f"  Shell: {user['shell']}")
    print()

    # Run checks
    run_all = args.all or not any([args.suid, args.caps, args.writable, args.cron,
                                    args.ssh, args.files, args.docker, args.kernel, args.sudo])

    if run_all or args.sudo:
        for line in check_sudo_nopasswd():
            print(line)
        print()

    if run_all or args.suid:
        for line in find_suid_sgid():
            print(line)
        print()

    if run_all or args.caps:
        for line in find_capabilities():
            print(line)
        print()

    if run_all or args.writable:
        for line in check_writable_paths():
            print(line)
        for line in check_writable_files():
            print(line)
        print()

    if run_all or args.cron:
        for line in check_cron_jobs():
            print(line)
        print()

    if run_all or args.ssh:
        for line in check_ssh_keys():
            print(line)
        print()

    if run_all or args.files:
        for line in check_interesting_files():
            print(line)
        print()

    if run_all or args.docker:
        findings = check_docker_lxc()
        if findings:
            for line in findings:
                print(line)
            print()

    if run_all or args.kernel:
        for line in check_kernel():
            print(line)
        print()

    print(f"{C.G}[*] Scan complete. Review findings for privilege escalation vectors.{C.E}")

if __name__ == '__main__':
    main()
